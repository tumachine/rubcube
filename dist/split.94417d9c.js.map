{"version":3,"sources":["lib/split/split.js","split.js"],"names":["Split","global","window","document","addEventListener","removeEventListener","getBoundingClientRect","gutterStartDragging","aGutterSize","bGutterSize","HORIZONTAL","NOOP","isIE8","attachEvent","calc","filter","prefix","el","createElement","style","cssText","length","shift","isString","v","String","elementOrSelector","ele","querySelector","Error","getOption","options","propName","def","value","undefined","getGutterSize","gutterSize","isFirst","isLast","gutterAlign","defaultGutterFn","i","gutterDirection","gut","className","defaultElementStyleFn","dim","size","gutSize","defaultGutterStyleFn","idsOption","dimension","clientAxis","position","positionEnd","clientSize","elements","ids","Array","from","firstElement","parent","parentNode","parentStyle","getComputedStyle","parentFlexDirection","flexDirection","sizes","map","minSize","minSizes","isArray","expandToMin","snapOffset","dragInterval","direction","cursor","gutter","elementStyle","gutterStyle","setElementSize","Object","keys","forEach","prop","getSizes","element","getMousePosition","e","touches","adjust","offset","a","b","percentage","calculateSizes","aBounds","bBounds","start","end","trimToMin","sizesToTrim","parentSize","innerSize","computedStyle","parseFloat","paddingLeft","paddingRight","paddingTop","paddingBottom","reduce","excessPixels","toSpare","pixelSizes","pixelSize","elementGutterSize","elementMinSize","push","newPixelSize","takenPixels","Math","min","startDragging","button","self","dragging","preventDefault","move","drag","dragOffset","round","call","bind","stop","stopDragging","userSelect","webkitUserSelect","MozUserSelect","pointerEvents","body","pairs","adjustToMin","pair","setSizes","newSizes","trimmed","newSize","destroy","preserveStyles","preserveGutter","removeChild","id","temp","gutterElement","setGutterSize","insertBefore","computedSize","collapse"],"mappings":"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","file":"split.94417d9c.js","sourceRoot":"..\\src","sourcesContent":["// The programming goals of Split.js are to deliver readable, understandable and\r\n// maintainable code, while at the same time manually optimizing for tiny minified file size,\r\n// browser compatibility without additional requirements, graceful fallback (IE8 is supported)\r\n// and very few assumptions about the user's page layout.\r\nconst global = window\r\nconst { document } = global\r\n\r\n// Save a couple long function names that are used frequently.\r\n// This optimization saves around 400 bytes.\r\nconst addEventListener = 'addEventListener'\r\nconst removeEventListener = 'removeEventListener'\r\nconst getBoundingClientRect = 'getBoundingClientRect'\r\nconst gutterStartDragging = '_a'\r\nconst aGutterSize = '_b'\r\nconst bGutterSize = '_c'\r\nconst HORIZONTAL = 'horizontal'\r\nconst NOOP = () => false\r\n\r\n// Figure out if we're in IE8 or not. IE8 will still render correctly,\r\n// but will be static instead of draggable.\r\nconst isIE8 = global.attachEvent && !global[addEventListener]\r\n\r\n// Helper function determines which prefixes of CSS calc we need.\r\n// We only need to do this once on startup, when this anonymous function is called.\r\n//\r\n// Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\r\n// http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\r\nconst calc = `${['', '-webkit-', '-moz-', '-o-']\r\n    .filter(prefix => {\r\n        const el = document.createElement('div')\r\n        el.style.cssText = `width:${prefix}calc(9px)`\r\n\r\n        return !!el.style.length\r\n    })\r\n    .shift()}calc`\r\n\r\n// Helper function checks if its argument is a string-like type\r\nconst isString = v => typeof v === 'string' || v instanceof String\r\n\r\n// Helper function allows elements and string selectors to be used\r\n// interchangeably. In either case an element is returned. This allows us to\r\n// do `Split([elem1, elem2])` as well as `Split(['#id1', '#id2'])`.\r\nconst elementOrSelector = el => {\r\n    if (isString(el)) {\r\n        const ele = document.querySelector(el)\r\n        if (!ele) {\r\n            throw new Error(`Selector ${el} did not match a DOM element`)\r\n        }\r\n        return ele\r\n    }\r\n\r\n    return el\r\n}\r\n\r\n// Helper function gets a property from the properties object, with a default fallback\r\nconst getOption = (options, propName, def) => {\r\n    const value = options[propName]\r\n    if (value !== undefined) {\r\n        return value\r\n    }\r\n    return def\r\n}\r\n\r\nconst getGutterSize = (gutterSize, isFirst, isLast, gutterAlign) => {\r\n    if (isFirst) {\r\n        if (gutterAlign === 'end') {\r\n            return 0\r\n        }\r\n        if (gutterAlign === 'center') {\r\n            return gutterSize / 2\r\n        }\r\n    } else if (isLast) {\r\n        if (gutterAlign === 'start') {\r\n            return 0\r\n        }\r\n        if (gutterAlign === 'center') {\r\n            return gutterSize / 2\r\n        }\r\n    }\r\n\r\n    return gutterSize\r\n}\r\n\r\n// Default options\r\nconst defaultGutterFn = (i, gutterDirection) => {\r\n    const gut = document.createElement('div')\r\n    gut.className = `gutter gutter-${gutterDirection}`\r\n    return gut\r\n}\r\n\r\nconst defaultElementStyleFn = (dim, size, gutSize) => {\r\n    const style = {}\r\n\r\n    if (!isString(size)) {\r\n        if (!isIE8) {\r\n            style[dim] = `${calc}(${size}% - ${gutSize}px)`\r\n        } else {\r\n            style[dim] = `${size}%`\r\n        }\r\n    } else {\r\n        style[dim] = size\r\n    }\r\n\r\n    return style\r\n}\r\n\r\nconst defaultGutterStyleFn = (dim, gutSize) => ({ [dim]: `${gutSize}px` })\r\n\r\n// The main function to initialize a split. Split.js thinks about each pair\r\n// of elements as an independant pair. Dragging the gutter between two elements\r\n// only changes the dimensions of elements in that pair. This is key to understanding\r\n// how the following functions operate, since each function is bound to a pair.\r\n//\r\n// A pair object is shaped like this:\r\n//\r\n// {\r\n//     a: DOM element,\r\n//     b: DOM element,\r\n//     aMin: Number,\r\n//     bMin: Number,\r\n//     dragging: Boolean,\r\n//     parent: DOM element,\r\n//     direction: 'horizontal' | 'vertical'\r\n// }\r\n//\r\n// The basic sequence:\r\n//\r\n// 1. Set defaults to something sane. `options` doesn't have to be passed at all.\r\n// 2. Initialize a bunch of strings based on the direction we're splitting.\r\n//    A lot of the behavior in the rest of the library is paramatized down to\r\n//    rely on CSS strings and classes.\r\n// 3. Define the dragging helper functions, and a few helpers to go with them.\r\n// 4. Loop through the elements while pairing them off. Every pair gets an\r\n//    `pair` object and a gutter.\r\n// 5. Actually size the pair elements, insert gutters and attach event listeners.\r\nconst Split = (idsOption, options = {}) => {\r\n    let ids = idsOption\r\n    let dimension\r\n    let clientAxis\r\n    let position\r\n    let positionEnd\r\n    let clientSize\r\n    let elements\r\n\r\n    // Allow HTMLCollection to be used as an argument when supported\r\n    if (Array.from) {\r\n        ids = Array.from(ids)\r\n    }\r\n\r\n    // All DOM elements in the split should have a common parent. We can grab\r\n    // the first elements parent and hope users read the docs because the\r\n    // behavior will be whacky otherwise.\r\n    const firstElement = elementOrSelector(ids[0])\r\n    const parent = firstElement.parentNode\r\n    const parentStyle = getComputedStyle ? getComputedStyle(parent) : null\r\n    const parentFlexDirection = parentStyle ? parentStyle.flexDirection : null\r\n\r\n    // Set default options.sizes to equal percentages of the parent element.\r\n    let sizes = getOption(options, 'sizes') || ids.map(() => 100 / ids.length)\r\n\r\n    // Standardize minSize to an array if it isn't already. This allows minSize\r\n    // to be passed as a number.\r\n    const minSize = getOption(options, 'minSize', 100)\r\n    const minSizes = Array.isArray(minSize) ? minSize : ids.map(() => minSize)\r\n\r\n    // Get other options\r\n    const expandToMin = getOption(options, 'expandToMin', false)\r\n    const gutterSize = getOption(options, 'gutterSize', 10)\r\n    const gutterAlign = getOption(options, 'gutterAlign', 'center')\r\n    const snapOffset = getOption(options, 'snapOffset', 30)\r\n    const dragInterval = getOption(options, 'dragInterval', 1)\r\n    const direction = getOption(options, 'direction', HORIZONTAL)\r\n    const cursor = getOption(\r\n        options,\r\n        'cursor',\r\n        direction === HORIZONTAL ? 'col-resize' : 'row-resize',\r\n    )\r\n    const gutter = getOption(options, 'gutter', defaultGutterFn)\r\n    const elementStyle = getOption(\r\n        options,\r\n        'elementStyle',\r\n        defaultElementStyleFn,\r\n    )\r\n    const gutterStyle = getOption(options, 'gutterStyle', defaultGutterStyleFn)\r\n\r\n    // 2. Initialize a bunch of strings based on the direction we're splitting.\r\n    // A lot of the behavior in the rest of the library is paramatized down to\r\n    // rely on CSS strings and classes.\r\n    if (direction === HORIZONTAL) {\r\n        dimension = 'width'\r\n        clientAxis = 'clientX'\r\n        position = 'left'\r\n        positionEnd = 'right'\r\n        clientSize = 'clientWidth'\r\n    } else if (direction === 'vertical') {\r\n        dimension = 'height'\r\n        clientAxis = 'clientY'\r\n        position = 'top'\r\n        positionEnd = 'bottom'\r\n        clientSize = 'clientHeight'\r\n    }\r\n\r\n    // 3. Define the dragging helper functions, and a few helpers to go with them.\r\n    // Each helper is bound to a pair object that contains its metadata. This\r\n    // also makes it easy to store references to listeners that that will be\r\n    // added and removed.\r\n    //\r\n    // Even though there are no other functions contained in them, aliasing\r\n    // this to self saves 50 bytes or so since it's used so frequently.\r\n    //\r\n    // The pair object saves metadata like dragging state, position and\r\n    // event listener references.\r\n\r\n    function setElementSize(el, size, gutSize, i) {\r\n        // Split.js allows setting sizes via numbers (ideally), or if you must,\r\n        // by string, like '300px'. This is less than ideal, because it breaks\r\n        // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\r\n        // make sure you calculate the gutter size by hand.\r\n        const style = elementStyle(dimension, size, gutSize, i)\r\n\r\n        Object.keys(style).forEach(prop => {\r\n            // eslint-disable-next-line no-param-reassign\r\n            el.style[prop] = style[prop]\r\n        })\r\n    }\r\n\r\n    function setGutterSize(gutterElement, gutSize, i) {\r\n        const style = gutterStyle(dimension, gutSize, i)\r\n\r\n        Object.keys(style).forEach(prop => {\r\n            // eslint-disable-next-line no-param-reassign\r\n            gutterElement.style[prop] = style[prop]\r\n        })\r\n    }\r\n\r\n    function getSizes() {\r\n        return elements.map(element => element.size)\r\n    }\r\n\r\n    // Supports touch events, but not multitouch, so only the first\r\n    // finger `touches[0]` is counted.\r\n    function getMousePosition(e) {\r\n        if ('touches' in e) return e.touches[0][clientAxis]\r\n        return e[clientAxis]\r\n    }\r\n\r\n    // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\r\n    // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\r\n    // which allows the viewport to be resized without additional logic.\r\n    // Element a's size is the same as offset. b's size is total size - a size.\r\n    // Both sizes are calculated from the initial parent percentage,\r\n    // then the gutter size is subtracted.\r\n    function adjust(offset) {\r\n        const a = elements[this.a]\r\n        const b = elements[this.b]\r\n        const percentage = a.size + b.size\r\n\r\n        a.size = (offset / this.size) * percentage\r\n        b.size = percentage - (offset / this.size) * percentage\r\n\r\n        setElementSize(a.element, a.size, this[aGutterSize], a.i)\r\n        setElementSize(b.element, b.size, this[bGutterSize], b.i)\r\n    }\r\n\r\n    // drag, where all the magic happens. The logic is really quite simple:\r\n    //\r\n    // 1. Ignore if the pair is not dragging.\r\n    // 2. Get the offset of the event.\r\n    // 3. Snap offset to min if within snappable range (within min + snapOffset).\r\n    // 4. Actually adjust each element in the pair to offset.\r\n    //\r\n    // ---------------------------------------------------------------------\r\n    // |    | <- a.minSize               ||              b.minSize -> |    |\r\n    // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\r\n    // |    |  |                         ||                        |  |    |\r\n    // |    |  |                         ||                        |  |    |\r\n    // ---------------------------------------------------------------------\r\n    // | <- this.start                                        this.size -> |\r\n    function drag(e) {\r\n        let offset\r\n        const a = elements[this.a]\r\n        const b = elements[this.b]\r\n\r\n        if (!this.dragging) return\r\n\r\n        // Get the offset of the event from the first side of the\r\n        // pair `this.start`. Then offset by the initial position of the\r\n        // mouse compared to the gutter size.\r\n        offset =\r\n            getMousePosition(e) -\r\n            this.start +\r\n            (this[aGutterSize] - this.dragOffset)\r\n\r\n        if (dragInterval > 1) {\r\n            offset = Math.round(offset / dragInterval) * dragInterval\r\n        }\r\n\r\n        // If within snapOffset of min or max, set offset to min or max.\r\n        // snapOffset buffers a.minSize and b.minSize, so logic is opposite for both.\r\n        // Include the appropriate gutter sizes to prevent overflows.\r\n        if (offset <= a.minSize + snapOffset + this[aGutterSize]) {\r\n            offset = a.minSize + this[aGutterSize]\r\n        } else if (\r\n            offset >=\r\n            this.size - (b.minSize + snapOffset + this[bGutterSize])\r\n        ) {\r\n            offset = this.size - (b.minSize + this[bGutterSize])\r\n        }\r\n\r\n        // Actually adjust the size.\r\n        adjust.call(this, offset)\r\n\r\n        // Call the drag callback continously. Don't do anything too intensive\r\n        // in this callback.\r\n        getOption(options, 'onDrag', NOOP)()\r\n    }\r\n\r\n    // Cache some important sizes when drag starts, so we don't have to do that\r\n    // continously:\r\n    //\r\n    // `size`: The total size of the pair. First + second + first gutter + second gutter.\r\n    // `start`: The leading side of the first element.\r\n    //\r\n    // ------------------------------------------------\r\n    // |      aGutterSize -> |||                      |\r\n    // |                     |||                      |\r\n    // |                     |||                      |\r\n    // |                     ||| <- bGutterSize       |\r\n    // ------------------------------------------------\r\n    // | <- start                             size -> |\r\n    function calculateSizes() {\r\n        // Figure out the parent size minus padding.\r\n        const a = elements[this.a].element\r\n        const b = elements[this.b].element\r\n\r\n        const aBounds = a[getBoundingClientRect]()\r\n        const bBounds = b[getBoundingClientRect]()\r\n\r\n        this.size =\r\n            aBounds[dimension] +\r\n            bBounds[dimension] +\r\n            this[aGutterSize] +\r\n            this[bGutterSize]\r\n        this.start = aBounds[position]\r\n        this.end = aBounds[positionEnd]\r\n    }\r\n\r\n    function innerSize(element) {\r\n        // Return nothing if getComputedStyle is not supported (< IE9)\r\n        // Or if parent element has no layout yet\r\n        if (!getComputedStyle) return null\r\n\r\n        const computedStyle = getComputedStyle(element)\r\n\r\n        if (!computedStyle) return null\r\n\r\n        let size = element[clientSize]\r\n\r\n        if (size === 0) return null\r\n\r\n        if (direction === HORIZONTAL) {\r\n            size -=\r\n                parseFloat(computedStyle.paddingLeft) +\r\n                parseFloat(computedStyle.paddingRight)\r\n        } else {\r\n            size -=\r\n                parseFloat(computedStyle.paddingTop) +\r\n                parseFloat(computedStyle.paddingBottom)\r\n        }\r\n\r\n        return size\r\n    }\r\n\r\n    // When specifying percentage sizes that are less than the computed\r\n    // size of the element minus the gutter, the lesser percentages must be increased\r\n    // (and decreased from the other elements) to make space for the pixels\r\n    // subtracted by the gutters.\r\n    function trimToMin(sizesToTrim) {\r\n        // Try to get inner size of parent element.\r\n        // If it's no supported, return original sizes.\r\n        const parentSize = innerSize(parent)\r\n        if (parentSize === null) {\r\n            return sizesToTrim\r\n        }\r\n\r\n        if (minSizes.reduce((a, b) => a + b, 0) > parentSize) {\r\n            return sizesToTrim\r\n        }\r\n\r\n        // Keep track of the excess pixels, the amount of pixels over the desired percentage\r\n        // Also keep track of the elements with pixels to spare, to decrease after if needed\r\n        let excessPixels = 0\r\n        const toSpare = []\r\n\r\n        const pixelSizes = sizesToTrim.map((size, i) => {\r\n            // Convert requested percentages to pixel sizes\r\n            const pixelSize = (parentSize * size) / 100\r\n            const elementGutterSize = getGutterSize(\r\n                gutterSize,\r\n                i === 0,\r\n                i === sizesToTrim.length - 1,\r\n                gutterAlign,\r\n            )\r\n            const elementMinSize = minSizes[i] + elementGutterSize\r\n\r\n            // If element is too smal, increase excess pixels by the difference\r\n            // and mark that it has no pixels to spare\r\n            if (pixelSize < elementMinSize) {\r\n                excessPixels += elementMinSize - pixelSize\r\n                toSpare.push(0)\r\n                return elementMinSize\r\n            }\r\n\r\n            // Otherwise, mark the pixels it has to spare and return it's original size\r\n            toSpare.push(pixelSize - elementMinSize)\r\n            return pixelSize\r\n        })\r\n\r\n        // If nothing was adjusted, return the original sizes\r\n        if (excessPixels === 0) {\r\n            return sizesToTrim\r\n        }\r\n\r\n        return pixelSizes.map((pixelSize, i) => {\r\n            let newPixelSize = pixelSize\r\n\r\n            // While there's still pixels to take, and there's enough pixels to spare,\r\n            // take as many as possible up to the total excess pixels\r\n            if (excessPixels > 0 && toSpare[i] - excessPixels > 0) {\r\n                const takenPixels = Math.min(\r\n                    excessPixels,\r\n                    toSpare[i] - excessPixels,\r\n                )\r\n\r\n                // Subtract the amount taken for the next iteration\r\n                excessPixels -= takenPixels\r\n                newPixelSize = pixelSize - takenPixels\r\n            }\r\n\r\n            // Return the pixel size adjusted as a percentage\r\n            return (newPixelSize / parentSize) * 100\r\n        })\r\n    }\r\n\r\n    // stopDragging is very similar to startDragging in reverse.\r\n    function stopDragging() {\r\n        const self = this\r\n        const a = elements[self.a].element\r\n        const b = elements[self.b].element\r\n\r\n        if (self.dragging) {\r\n            getOption(options, 'onDragEnd', NOOP)(getSizes())\r\n        }\r\n\r\n        self.dragging = false\r\n\r\n        // Remove the stored event listeners. This is why we store them.\r\n        global[removeEventListener]('mouseup', self.stop)\r\n        global[removeEventListener]('touchend', self.stop)\r\n        global[removeEventListener]('touchcancel', self.stop)\r\n        global[removeEventListener]('mousemove', self.move)\r\n        global[removeEventListener]('touchmove', self.move)\r\n\r\n        // Clear bound function references\r\n        self.stop = null\r\n        self.move = null\r\n\r\n        a[removeEventListener]('selectstart', NOOP)\r\n        a[removeEventListener]('dragstart', NOOP)\r\n        b[removeEventListener]('selectstart', NOOP)\r\n        b[removeEventListener]('dragstart', NOOP)\r\n\r\n        a.style.userSelect = ''\r\n        a.style.webkitUserSelect = ''\r\n        a.style.MozUserSelect = ''\r\n        a.style.pointerEvents = ''\r\n\r\n        b.style.userSelect = ''\r\n        b.style.webkitUserSelect = ''\r\n        b.style.MozUserSelect = ''\r\n        b.style.pointerEvents = ''\r\n\r\n        self.gutter.style.cursor = ''\r\n        self.parent.style.cursor = ''\r\n        document.body.style.cursor = ''\r\n    }\r\n\r\n    // startDragging calls `calculateSizes` to store the inital size in the pair object.\r\n    // It also adds event listeners for mouse/touch events,\r\n    // and prevents selection while dragging so avoid the selecting text.\r\n    function startDragging(e) {\r\n        // Right-clicking can't start dragging.\r\n        if ('button' in e && e.button !== 0) {\r\n            return\r\n        }\r\n\r\n        // Alias frequently used variables to save space. 200 bytes.\r\n        const self = this\r\n        const a = elements[self.a].element\r\n        const b = elements[self.b].element\r\n\r\n        // Call the onDragStart callback.\r\n        if (!self.dragging) {\r\n            getOption(options, 'onDragStart', NOOP)(getSizes())\r\n        }\r\n\r\n        // Don't actually drag the element. We emulate that in the drag function.\r\n        e.preventDefault()\r\n\r\n        // Set the dragging property of the pair object.\r\n        self.dragging = true\r\n\r\n        // Create two event listeners bound to the same pair object and store\r\n        // them in the pair object.\r\n        self.move = drag.bind(self)\r\n        self.stop = stopDragging.bind(self)\r\n\r\n        // All the binding. `window` gets the stop events in case we drag out of the elements.\r\n        global[addEventListener]('mouseup', self.stop)\r\n        global[addEventListener]('touchend', self.stop)\r\n        global[addEventListener]('touchcancel', self.stop)\r\n        global[addEventListener]('mousemove', self.move)\r\n        global[addEventListener]('touchmove', self.move)\r\n\r\n        // Disable selection. Disable!\r\n        a[addEventListener]('selectstart', NOOP)\r\n        a[addEventListener]('dragstart', NOOP)\r\n        b[addEventListener]('selectstart', NOOP)\r\n        b[addEventListener]('dragstart', NOOP)\r\n\r\n        a.style.userSelect = 'none'\r\n        a.style.webkitUserSelect = 'none'\r\n        a.style.MozUserSelect = 'none'\r\n        a.style.pointerEvents = 'none'\r\n\r\n        b.style.userSelect = 'none'\r\n        b.style.webkitUserSelect = 'none'\r\n        b.style.MozUserSelect = 'none'\r\n        b.style.pointerEvents = 'none'\r\n\r\n        // Set the cursor at multiple levels\r\n        self.gutter.style.cursor = cursor\r\n        self.parent.style.cursor = cursor\r\n        document.body.style.cursor = cursor\r\n\r\n        // Cache the initial sizes of the pair.\r\n        calculateSizes.call(self)\r\n\r\n        // Determine the position of the mouse compared to the gutter\r\n        self.dragOffset = getMousePosition(e) - self.end\r\n    }\r\n\r\n    // adjust sizes to ensure percentage is within min size and gutter.\r\n    sizes = trimToMin(sizes)\r\n\r\n    // 5. Create pair and element objects. Each pair has an index reference to\r\n    // elements `a` and `b` of the pair (first and second elements).\r\n    // Loop through the elements while pairing them off. Every pair gets a\r\n    // `pair` object and a gutter.\r\n    //\r\n    // Basic logic:\r\n    //\r\n    // - Starting with the second element `i > 0`, create `pair` objects with\r\n    //   `a = i - 1` and `b = i`\r\n    // - Set gutter sizes based on the _pair_ being first/last. The first and last\r\n    //   pair have gutterSize / 2, since they only have one half gutter, and not two.\r\n    // - Create gutter elements and add event listeners.\r\n    // - Set the size of the elements, minus the gutter sizes.\r\n    //\r\n    // -----------------------------------------------------------------------\r\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\r\n    // |             |                     |                  |              |\r\n    // |           pair 0                pair 1             pair 2           |\r\n    // |             |                     |                  |              |\r\n    // -----------------------------------------------------------------------\r\n    const pairs = []\r\n    elements = ids.map((id, i) => {\r\n        // Create the element object.\r\n        const element = {\r\n            element: elementOrSelector(id),\r\n            size: sizes[i],\r\n            minSize: minSizes[i],\r\n            i,\r\n        }\r\n\r\n        let pair\r\n\r\n        if (i > 0) {\r\n            // Create the pair object with its metadata.\r\n            pair = {\r\n                a: i - 1,\r\n                b: i,\r\n                dragging: false,\r\n                direction,\r\n                parent,\r\n            }\r\n\r\n            pair[aGutterSize] = getGutterSize(\r\n                gutterSize,\r\n                i - 1 === 0,\r\n                false,\r\n                gutterAlign,\r\n            )\r\n            pair[bGutterSize] = getGutterSize(\r\n                gutterSize,\r\n                false,\r\n                i === ids.length - 1,\r\n                gutterAlign,\r\n            )\r\n\r\n            // if the parent has a reverse flex-direction, switch the pair elements.\r\n            if (\r\n                parentFlexDirection === 'row-reverse' ||\r\n                parentFlexDirection === 'column-reverse'\r\n            ) {\r\n                const temp = pair.a\r\n                pair.a = pair.b\r\n                pair.b = temp\r\n            }\r\n        }\r\n\r\n        // Determine the size of the current element. IE8 is supported by\r\n        // staticly assigning sizes without draggable gutters. Assigns a string\r\n        // to `size`.\r\n        //\r\n        // IE9 and above\r\n        if (!isIE8) {\r\n            // Create gutter elements for each pair.\r\n            if (i > 0) {\r\n                const gutterElement = gutter(i, direction, element.element)\r\n                setGutterSize(gutterElement, gutterSize, i)\r\n\r\n                // Save bound event listener for removal later\r\n                pair[gutterStartDragging] = startDragging.bind(pair)\r\n\r\n                // Attach bound event listener\r\n                gutterElement[addEventListener](\r\n                    'mousedown',\r\n                    pair[gutterStartDragging],\r\n                )\r\n                gutterElement[addEventListener](\r\n                    'touchstart',\r\n                    pair[gutterStartDragging],\r\n                )\r\n\r\n                parent.insertBefore(gutterElement, element.element)\r\n\r\n                pair.gutter = gutterElement\r\n            }\r\n        }\r\n\r\n        setElementSize(\r\n            element.element,\r\n            element.size,\r\n            getGutterSize(\r\n                gutterSize,\r\n                i === 0,\r\n                i === ids.length - 1,\r\n                gutterAlign,\r\n            ),\r\n            i,\r\n        )\r\n\r\n        // After the first iteration, and we have a pair object, append it to the\r\n        // list of pairs.\r\n        if (i > 0) {\r\n            pairs.push(pair)\r\n        }\r\n\r\n        return element\r\n    })\r\n\r\n    function adjustToMin(element) {\r\n        const isLast = element.i === pairs.length\r\n        const pair = isLast ? pairs[element.i - 1] : pairs[element.i]\r\n\r\n        calculateSizes.call(pair)\r\n\r\n        const size = isLast\r\n            ? pair.size - element.minSize - pair[bGutterSize]\r\n            : element.minSize + pair[aGutterSize]\r\n\r\n        adjust.call(pair, size)\r\n    }\r\n\r\n    elements.forEach(element => {\r\n        const computedSize = element.element[getBoundingClientRect]()[dimension]\r\n\r\n        if (computedSize < element.minSize) {\r\n            if (expandToMin) {\r\n                adjustToMin(element)\r\n            } else {\r\n                // eslint-disable-next-line no-param-reassign\r\n                element.minSize = computedSize\r\n            }\r\n        }\r\n    })\r\n\r\n    function setSizes(newSizes) {\r\n        const trimmed = trimToMin(newSizes)\r\n        trimmed.forEach((newSize, i) => {\r\n            if (i > 0) {\r\n                const pair = pairs[i - 1]\r\n\r\n                const a = elements[pair.a]\r\n                const b = elements[pair.b]\r\n\r\n                a.size = trimmed[i - 1]\r\n                b.size = newSize\r\n\r\n                setElementSize(a.element, a.size, pair[aGutterSize], a.i)\r\n                setElementSize(b.element, b.size, pair[bGutterSize], b.i)\r\n            }\r\n        })\r\n    }\r\n\r\n    function destroy(preserveStyles, preserveGutter) {\r\n        pairs.forEach(pair => {\r\n            if (preserveGutter !== true) {\r\n                pair.parent.removeChild(pair.gutter)\r\n            } else {\r\n                pair.gutter[removeEventListener](\r\n                    'mousedown',\r\n                    pair[gutterStartDragging],\r\n                )\r\n                pair.gutter[removeEventListener](\r\n                    'touchstart',\r\n                    pair[gutterStartDragging],\r\n                )\r\n            }\r\n\r\n            if (preserveStyles !== true) {\r\n                const style = elementStyle(\r\n                    dimension,\r\n                    pair.a.size,\r\n                    pair[aGutterSize],\r\n                )\r\n\r\n                Object.keys(style).forEach(prop => {\r\n                    elements[pair.a].element.style[prop] = ''\r\n                    elements[pair.b].element.style[prop] = ''\r\n                })\r\n            }\r\n        })\r\n    }\r\n\r\n    if (isIE8) {\r\n        return {\r\n            setSizes,\r\n            destroy,\r\n        }\r\n    }\r\n\r\n    return {\r\n        setSizes,\r\n        getSizes,\r\n        collapse(i) {\r\n            adjustToMin(elements[i])\r\n        },\r\n        destroy,\r\n        parent,\r\n        pairs,\r\n    }\r\n}\r\n\r\nexport default Split\r\n","// Three.js - Responsive Editor\r\n// from https://threejsfundamentals.org/threejs/threejs-responsive-editor.html\r\n\r\nimport Split from './lib/split/split';\r\n\r\n/* global Split */\r\n\r\n// This code is only related to handling the split.\r\n// Our three.js code has not changed\r\nSplit(['#view', '#controls'], { // eslint-disable-line new-cap\r\n  sizes: [75, 25],\r\n  minSize: 100,\r\n  elementStyle: (dimension, size, gutterSize) => ({\r\n    'flex-basis': `calc(${size}% - ${gutterSize}px)`,\r\n  }),\r\n  gutterStyle: (dimension, gutterSize) => ({\r\n    'flex-basis': `${gutterSize}px`,\r\n  }),\r\n});\r\n"]}